import "customGameSettings.lobby";

globalvar Team PowerupTeam;

playervar Number[] powerupInventory = [
  2,                  // FULL_HEALTH
  2,                  // IMMORTALITY
  2,                  // SELF_RES
  2,                  // DAMAGE_BOOST,
  2,                  // SPEED_BOOST,
  2,                  // INVISIBILITY,
  2,                  // SHRINKING,
  2,                  // ENLARGENING,
  2,                  // COOLDOWN_HASTE,
  2,                  // BLINDNESS,
  2                   // INSTA_ULT,
];
playervar Number powerupIndex;
playervar Boolean canActivatePowerupFlag = false;
playervar String lastPowerupName;
playervar Boolean inventoryIsEmpty; // Caches inventory status
playervar Any transformEffect;
playervar Number credits; // TODO: Implement costs and purchasing

enum PowerupType {
  FULL_HEALTH,
  IMMORTALITY,
  SELF_RES,
  DAMAGE_BOOST,
  SPEED_BOOST,
  INVISIBILITY,
  SHRINKING,
  ENLARGENING,
  COOLDOWN_HASTE,
  BLINDNESS,
  INSTA_ULT
}
// ABILITY NAME                            ENUM VALUE         ABILITY ICON
globalvar String[] powerupNames = [
  "Full Health Potion",                 // FULL_HEALTH        Regenerative Burst
  "Immortality Potion",                 // IMMORTALITY        Immortality Field
  "Self-Resurrect Totem",               // SELF_RES           Resurrect
  "Damage Boost Stim",                  // DAMAGE_BOOST,      Amp Matrix or Nano Boost
  "Speed Boost Stim",                   // SPEED_BOOST,       Charge
  "Invisibility Dust",                  // INVISIBILITY,      Eye
  "Shrinking Tablet",                   // SHRINKING,         Piledriver
  "Giant Juice",                        // ENLARGENING,       Exo Boots
  "Cooldown Hastener",                  // COOLDOWN_HASTE,    Amp It Up
  "Smoke Bomb",                         // BLINDNESS,         Dizzy
  "Insta-Ult Pack"                      // INSTA_ULT,         Overload
];

rule: "Set Powerup Team - not in global initialization rule to ensure ordering" -1
{
  PowerupTeam = [Team.Team1, Team.Team2][WorkshopSettingCombo("Settings", "Powerups Team", 0, ["Team 1", "Team 2"], 0)];
}

rule: 'Interact to use Powerup'
Event.OngoingPlayer
if (TeamOf(EventPlayer()) == PowerupTeam)
if (IsButtonHeld(Button: Button.Interact))
{
  CheckUse();
  if (!canActivatePowerupFlag) {
    SmallMessage(EventPlayer(), <"<0> can't be used right now!", powerupNames[powerupIndex]>);
    PlayEffect(EventPlayer(), PlayEffect.DebuffImpactSound, null, EventPlayer(), 50);
    return;
  }
  UseCurrentPower();
}

void CheckUse() "[SUB] Can player use the currently selected powerup?"
{
  # Check current powerup, and cancel if empty
  if (powerupInventory[powerupIndex] == 0) {
    return;
  }
  # Cannot use by default
  canActivatePowerupFlag = false;
  switch(powerupIndex) {
    case PowerupType.FULL_HEALTH:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && Health(EventPlayer()) < MaxHealth(EventPlayer());
      break;
    case PowerupType.IMMORTALITY:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && immortalityTimer == 0;
      break;
    case PowerupType.SELF_RES:
      canActivatePowerupFlag = IsDead(EventPlayer());
      break;
    case PowerupType.DAMAGE_BOOST:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && (canStackDamageBoosts || CountOf(damageBoostExpiryTimes) == 0);
      break;
    case PowerupType.SPEED_BOOST:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && (canStackSpeedBoosts || CountOf(speedBoostExpiryTimes) == 0);
      break;
    case PowerupType.INVISIBILITY:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && invisibilityTimer == 0;
      break;
    case PowerupType.SHRINKING:
    case PowerupType.ENLARGENING:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && shrinkTimer == 0 && giantTimer == 0;
      break;
    case PowerupType.COOLDOWN_HASTE:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && cooldownHasteTimer == 0;
      break;
  }
}

void UseCurrentPower() "[SUB] Dispatcher for powerup use event"
{
  switch(powerupIndex) {
    case PowerupType.FULL_HEALTH:
      async useFullRestore();
      break;
    case PowerupType.IMMORTALITY:
      useImmortality();
      break;
    case PowerupType.SELF_RES:
      resSelf();
      break;
    case PowerupType.DAMAGE_BOOST:
      useDamageBooster();
      break;
    case PowerupType.SPEED_BOOST:
      useSpeedBooster();
      break;
    case PowerupType.INVISIBILITY:
      useInvisibility();
      break;
    case PowerupType.SHRINKING:
      useShrink();
      break;
    case PowerupType.ENLARGENING:
      useGiant();
      break;
    case PowerupType.COOLDOWN_HASTE:
      useCooldownHaste();
      break;
  }
  # Decrement inventory of powerups
  powerupInventory[powerupIndex] -= 1;
  # Confirm use (cache name to avoid deferment issues)
  lastPowerupName = powerupNames[powerupIndex];
  SmallMessage(EventPlayer(), <"Used <0>", lastPowerupName>);
  # Select next available option if out now
  if (powerupInventory[powerupIndex] == 0) {
    incrementPowerupIndex();
    # If we're still at 0, there's nothing left in the inventory.
    if (powerupInventory[powerupIndex] == 0) {
      inventoryIsEmpty = true;
    }
  }
}

rule: "Initialize player HUD"
Event.OnPlayerJoin
if (TeamOf(EventPlayer()) == PowerupTeam)
{
  CreateHudText(
    VisibleTo:          EventPlayer(),
    Header:             inventoryIsEmpty
                        ? "   No Items   "
                        : <"   [<1> + <2>] <4>       <0> [<6>]       <5> [<1> + <3>]   ",
                            powerupNames[powerupIndex],
                            InputBindingString(Button.Reload),
                            InputBindingString(Button.PrimaryFire),
                            InputBindingString(Button.SecondaryFire),
                            IconString(Icon.ArrowLeft),
                            IconString(Icon.ArrowRight),
                            powerupInventory[powerupIndex]
                        >,
    Subheader:          " ",
    Text:               " ",
    Location.Top,
    SortOrder:          3,
    Reevaluation:       HudTextRev.VisibleToAndString,
    Spectators:         Spectators.DefaultVisibility
  );
}

rule: "Scroll forward and back between usable items"
Event.OngoingPlayer
if (TeamOf(EventPlayer()) == PowerupTeam)
if (IsButtonHeld(Button: Button.Reload))
if (IsButtonHeld(Button: Button.PrimaryFire) || IsButtonHeld(Button: Button.SecondaryFire))
{
  AbortIf(CountOf(FilteredArray(powerupInventory, ArrayElement() > 0)) < 2);
  if (IsButtonHeld(Button: Button.PrimaryFire)) {
    decrementPowerupIndex();
  } else if (IsButtonHeld(Button: Button.SecondaryFire)) {
    incrementPowerupIndex();
  }
}

rule: "Disable selection buttons"
Event.OngoingPlayer
if (IsButtonHeld(Button: Button.Reload))
{
  DisallowButton(Button: Button.PrimaryFire);
  DisallowButton(Button: Button.SecondaryFire);
  WaitUntil(
    ContinueCondition:          !IsButtonHeld(Button: Button.Reload),
    Timeout:                    9999
  );
  AllowButton(Button: Button.PrimaryFire);
  AllowButton(Button: Button.SecondaryFire);
}

playervar Number explorePowerupIndex;

void decrementPowerupIndex() "[SUB] Find next valid powerupIndex in the negative direction"
{
  explorePowerupIndex = powerupIndex - 1;
  while (powerupInventory[explorePowerupIndex] == 0 && explorePowerupIndex != powerupIndex) {
    explorePowerupIndex -= 1;
    if (explorePowerupIndex < 0) {
      explorePowerupIndex = CountOf(powerupNames) - 1;
    }
  }
  powerupIndex = explorePowerupIndex;
}

void incrementPowerupIndex() "[SUB] Find next valid powerupIndex in the positive direction" {
  explorePowerupIndex = powerupIndex + 1;
  while (powerupInventory[explorePowerupIndex] == 0 && explorePowerupIndex != powerupIndex) {
    explorePowerupIndex += 1;
    if (explorePowerupIndex >= CountOf(powerupNames)) {
      explorePowerupIndex = 0;
    }
  }
  powerupIndex = explorePowerupIndex;
}

import "powerups/fullRestore.ostw";
import "powerups/immortality.ostw";
import "powerups/selfRes.ostw";
import "powerups/damageBoost.ostw";
import "powerups/speedBoost.ostw";
import "powerups/invisibility.ostw";
import "powerups/shrinking.ostw";
import "powerups/giant.ostw";
import "powerups/cooldownHaste.ostw";

// TODO: Automatically choose a new powerup when the current one is exhausted
// TODO: Create powerup selection interface

import "debug.ostw";
