import "customGameSettings.lobby";
enum TalentType {
  MOVE_SPEED, // 0
  MAX_HEALTH, // 1
  DAMAGE_DEALT, // 2
  COOLDOWN, // 3
  ULTIMATE_GENERATION, // 4
  DAMAGE_RECEIVED // 5
}
Number numOfPowerups: talentData.Length;
globalvar TalentData[] talentData = [
  {
    Name: "Move Speed",
    // Price: WorkshopSettingInteger("Talent Prices", "Move Speed Price", 10, 0, 100, 100),
    Price: 0,
    Color: CustomColor(132, 204, 101, 255),
    Description: "+<X>% to base movement speed",
    BonusAmount: WorkshopSettingInteger("Move Speed Talent", "Move Speed % Bonus", 20, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Move Speed Talent", "Move Speed Max Stacks", 5, 1, 10, 1),
  },
  {
    Name: "Max Health",
    // Price: WorkshopSettingInteger("Talent Prices", "Max Health Price", 10, 0, 100, 101),
    Price: 0,
    Color: CustomColor(230, 81,  81,  255),
    Description: "+<X>% to base max health",
    BonusAmount: WorkshopSettingInteger("Max Health Talent", "Max Health % Bonus", 20, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Max Health Talent", "Max Health Max Stacks", 5, 1, 10, 1),
  },
  {
    Name: "Damage Dealt",
    // Price: WorkshopSettingInteger("Talent Prices", "Damage Dealt Price", 10, 0, 100, 101),
    Price: 0,
    Color: CustomColor(169, 255, 252, 255),
    Description: "+<X>% to base damage",
    BonusAmount: WorkshopSettingInteger("Damage Dealt Talent", "Damage Dealt % Bonus", 20, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Damage Dealt Talent", "Damage Dealt Max Stacks", 5, 1, 10, 1),
  },
  {
    Name: "Cooldown Speed",
    // Price: WorkshopSettingInteger("Talent Prices", "Cooldown Speed Price", 10, 0, 100, 101),
    Price: 0,
    Color: CustomColor(239, 241, 93, 255),
    Description: "+<X>% faster cooldowns",
    BonusAmount: WorkshopSettingInteger("Cooldown Speed Talent", "Cooldown Speed % Bonus", 10, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Cooldown Speed Talent", "Cooldown Speed Max Stacks", 5, 1, 10, 1),
  },
  {
    Name: "Ultimate Generation",
    // Price: WorkshopSettingInteger("Talent Prices", "Ultimate Generation Price", 10, 0, 100, 101),
    Price: 0,
    Color: CustomColor(255, 196, 40,  255),
    Description: "+<X>% faster ultimate generation",
    BonusAmount: WorkshopSettingInteger("Ultimate Generation Talent", "Ultimate Generation % Bonus", 10, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Ultimate Generation Talent", "Ultimate Generation Max Stacks", 5, 1, 10, 1),
  },
  {
    Name: "Damage Received",
    // Price: WorkshopSettingInteger("Talent Prices", "Damage Received Price", 10, 0, 100, 101),
    Price: 0,
    Color: CustomColor(252, 175, 203, 255),
    Description: "+<X>% less damage taken",
    BonusAmount: WorkshopSettingInteger("Damage Received Talent", "Damage Received % Bonus", 10, 0, 100, 0),
    MaxStacks: WorkshopSettingInteger("Damage Received Talent", "Damage Received Max Stacks", 5, 1, 10, 1),
  }
];
struct TalentData {
  public String Name;
  public Number Price;
  public Color Color;
  public String Description;
  public Number BonusAmount;
  public Number MaxStacks;
}

globalvar Team PowerupTeam;

playervar Number[] powerupInventory = [
  WorkshopSettingInteger("Starter Inventory", "Full Health Potions",    0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Immortality Potions",    0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Self-Resurrect Totems",  0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Damage Boost Stims",     0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Speed Boost Stims",      0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Invisibility Dust Bags", 0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Shrinking Tablets",      0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Giant Juice Vials",      0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Cooldown Hasteners",     0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Smoke Bombs",            0, 0, 20),
  WorkshopSettingInteger("Starter Inventory", "Insta-Ult Packs",        0, 0, 20)
];
playervar Number powerupIndex;
playervar Boolean canActivatePowerupFlag = false;
playervar String lastPowerupName;
playervar Boolean inventoryIsEmpty; // Caches inventory status
playervar Any transformEffect;
playervar Number[] talentBaseStats = [
  100,    // Move Speed
  100,    // Max Health
  100,    // Damage Dealt
  100,    // Cooldown
  100,    // Ultimate Generation
  100     // Damage Receieved
];
enum PowerupDataKey {
  Name,
  Price,
  Color
}

rule: "Ensure these settings appear first in the Workshop Settings menu" -1
{
  initialCredits = WorkshopSettingInteger("Settings", "Initial Credits Balance", 300, 0, 1000, 0);
  PowerupTeam = [Team.Team1, Team.Team2][WorkshopSettingCombo("Settings", "Powerups Team", 0, ["Team 1", "Team 2"], 0)];
}

rule: 'Interact to use Powerup'
Event.OngoingPlayer
if (TeamOf(EventPlayer()) == PowerupTeam)
if (IsButtonHeld(Button: Button.Interact))
{
  CheckUse();
  if (!canActivatePowerupFlag) {
    SmallMessage(EventPlayer(), <"<0> can't be used right now!", powerupData[powerupIndex][PowerupDataKey.Name]>);
    PlayEffect(EventPlayer(), PlayEffect.DebuffImpactSound, null, EventPlayer(), 50);
  } else {
    UseCurrentPower();
  }
    # Debounce
  Wait(0.25);
}

void CheckUse() "[SUB] Can player use the currently selected powerup?"
{
  # Check current powerup, and cancel if empty
  if (powerupInventory[powerupIndex] == 0) {
    return;
  }
  # Cannot use by default
  canActivatePowerupFlag = false;
  switch(powerupIndex) {
    case PowerupType.FULL_HEALTH:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && Health(EventPlayer()) < MaxHealth(EventPlayer());
      break;
    case PowerupType.IMMORTALITY:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && immortalityTimer == 0;
      break;
    case PowerupType.SELF_RES:
      canActivatePowerupFlag = IsDead(EventPlayer());
      break;
    case PowerupType.DAMAGE_BOOST:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && (canStackDamageBoosts || CountOf(damageBoostExpiryTimes) == 0);
      break;
    case PowerupType.SPEED_BOOST:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && (canStackSpeedBoosts || CountOf(speedBoostExpiryTimes) == 0);
      break;
    case PowerupType.INVISIBILITY:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && invisibilityTimer == 0;
      break;
    case PowerupType.SHRINKING:
    case PowerupType.ENLARGENING:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && shrinkTimer == 0 && giantTimer == 0;
      break;
    case PowerupType.COOLDOWN_HASTE:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && cooldownHasteTimer == 0;
      break;
    case PowerupType.BLINDNESS:
      canActivatePowerupFlag = IsAlive(EventPlayer());
      break;
    case PowerupType.INSTA_ULT:
      canActivatePowerupFlag = IsAlive(EventPlayer()) && UltimateChargePercent(EventPlayer()) < 100;
      break;
  }
}

void UseCurrentPower() "[SUB] Dispatcher for powerup use event"
{
  switch(powerupIndex) {
    case PowerupType.FULL_HEALTH:
      async useFullRestore();
      break;
    case PowerupType.IMMORTALITY:
      useImmortality();
      break;
    case PowerupType.SELF_RES:
      resSelf();
      break;
    case PowerupType.DAMAGE_BOOST:
      useDamageBooster();
      break;
    case PowerupType.SPEED_BOOST:
      useSpeedBooster();
      break;
    case PowerupType.INVISIBILITY:
      useInvisibility();
      break;
    case PowerupType.SHRINKING:
      useShrink();
      break;
    case PowerupType.ENLARGENING:
      useGiant();
      break;
    case PowerupType.COOLDOWN_HASTE:
      useCooldownHaste();
      break;
    case PowerupType.BLINDNESS:
      useSmokeBomb();
      break;
    case PowerupType.INSTA_ULT:
      useInstaUlt();
      break;
  }
  # Decrement inventory of powerups
  powerupInventory[powerupIndex] -= 1;
  # Confirm use (cache name to avoid deferment issues)
  lastPowerupName = powerupData[powerupIndex][PowerupDataKey.Name];
  SmallMessage(EventPlayer(), <"Used <0>", lastPowerupName>);
  # Select next available option if out now
  if (powerupInventory[powerupIndex] == 0) {
    incrementPowerupIndex();
    # If we're still at 0, there's nothing left in the inventory.
    if (powerupInventory[powerupIndex] == 0) {
      inventoryIsEmpty = true;
    }
  }
}

rule: "Initialize player HUD"
Event.OngoingPlayer
if (TeamOf(EventPlayer()) == PowerupTeam)
if (!IsWaitingForPlayers())
{
  CreateHudText(
    VisibleTo:          EventPlayer(),
    Header:             inventoryIsEmpty
                        ? "   No Items   "
                        : <" < [<1> + <2>]       <0> [<4>]       [<1> + <3>] > ",
                            powerupData[powerupIndex][PowerupDataKey.Name],
                            InputBindingString(Button.Reload),
                            InputBindingString(Button.PrimaryFire),
                            InputBindingString(Button.SecondaryFire),
                            powerupInventory[powerupIndex]
                        >,
    Subheader:          " ",
    Text:               " ",
    Location:           Location.Top,
    SortOrder:          3,
    HeaderColor:        inventoryIsEmpty ? Color.Red : powerupData[powerupIndex][PowerupDataKey.Color],
    Reevaluation:       HudTextRev.VisibleToAndString,
    Spectators:         Spectators.DefaultVisibility
  );
  if (IsTrueForAll(powerupInventory, ArrayElement() == 0)) {
    inventoryIsEmpty = true;
  }
}

rule: "Scroll forward and back between usable items"
Event.OngoingPlayer
if (TeamOf(EventPlayer()) == PowerupTeam)
if (IsButtonHeld(Button: Button.Reload))
if (IsButtonHeld(Button: Button.PrimaryFire) || IsButtonHeld(Button: Button.SecondaryFire))
{
  AbortIf(CountOf(FilteredArray(powerupInventory, ArrayElement() > 0)) < 2);
  if (IsButtonHeld(Button: Button.PrimaryFire)) {
    decrementPowerupIndex();
  } else if (IsButtonHeld(Button: Button.SecondaryFire)) {
    incrementPowerupIndex();
  }
}

rule: "Disable selection buttons"
Event.OngoingPlayer
if (IsButtonHeld(Button: Button.Reload))
{
  DisallowButton(Button: Button.PrimaryFire);
  DisallowButton(Button: Button.SecondaryFire);
  WaitUntil(
    ContinueCondition:          !IsButtonHeld(Button: Button.Reload),
    Timeout:                    9999
  );
  AllowButton(Button: Button.PrimaryFire);
  AllowButton(Button: Button.SecondaryFire);
}

playervar Number explorePowerupIndex;

void decrementPowerupIndex() "[SUB] Find next valid powerupIndex in the negative direction"
{
  explorePowerupIndex = powerupIndex - 1;
  while (powerupInventory[explorePowerupIndex] == 0 && explorePowerupIndex != powerupIndex) {
    explorePowerupIndex -= 1;
    if (explorePowerupIndex < 0) {
      explorePowerupIndex = CountOf(powerupData) - 1;
    }
  }
  powerupIndex = explorePowerupIndex;
}

void incrementPowerupIndex() "[SUB] Find next valid powerupIndex in the positive direction" {
  explorePowerupIndex = powerupIndex + 1;
  while (powerupInventory[explorePowerupIndex] == 0 && explorePowerupIndex != powerupIndex) {
    explorePowerupIndex += 1;
    if (explorePowerupIndex >= CountOf(powerupData)) {
      explorePowerupIndex = 0;
    }
  }
  powerupIndex = explorePowerupIndex;
}

import "powerups/fullRestore.ostw";
import "powerups/immortality.ostw";
import "powerups/selfRes.ostw";
import "powerups/damageBoost.ostw";
import "powerups/speedBoost.ostw";
import "powerups/invisibility.ostw";
import "powerups/shrinking.ostw";
import "powerups/giant.ostw";
import "powerups/cooldownHaste.ostw";
import "powerups/smokeBomb.ostw";
import "powerups/instaUlt.ostw";

import "talents/cooldown.ostw";
import "talents/damageDealt.ostw";
import "talents/damageReceived.ostw";
import "talents/moveSpeed.ostw";
import "talents/maxHealth.ostw";
import "talents/ultimateGeneration.ostw";

// import "debug.ostw";
